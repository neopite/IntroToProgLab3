[Повернутись](../index.md)
# [](#header-1)Assignment #3. Data structures

Варіант завдання – остача від ділення номеру бригади на 3. Варіантами можна _обмінюватись_, 
але не можна просто змінювати за власним бажанням. Будь ласка, перед виконанням заповніть [цю таблицю](https://docs.google.com/spreadsheets/d/1gXwSgYSGhvlDDNyUX3XfDecRc0SiDouf8GOyUXTqicg/edit#gid=1908643719). Вимоги до використання git такі самі, як і в попередній [роботі](./assignment_2.md). Також уважно ознайомтесь з загальними правилами здачі лабораторних та принципами оцінювання. 

Для підготовки до здачі роботи рекомендуємо користуватись книгою [Кормена](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B:_%D0%BF%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7) або [Скієни](http://www.twirpx.com/file/736147/) (їх можна знайти в мережі в електронному вигляді), а також будь-якими іншими джерелами – про базові структури даних існує безліч текстової інформації та відео.

## Питання та необхідні знання
Друга робота знайомить вас із імплементацією структур даних, які надалі використовуватимуться у більшості програм, які ви будете писати. В цій лабораторній для успішної здачі вам треба буде відповісти на кілька теоретичних питань. Отже для повноцінної здачі вам треба: 
* Знати, що таке О-велике і для чого воно використовується.
* Розуміти, чому алгоритми та структури, запропоновані в цій роботі, мають ту чи іншу асимптотичну слкадність *(вивчити напам'ять не значить зрозуміти, для здачі треба буде відповісти на питання чому певні алгоритми або структури мають саме таку складність, а не яку вони мають складність)*.
* Мати уявлення, в яких випадках краще використовувати одні структури, а в яких – інші.
* Розбиратися в структурах stack, queue, priority queue, linked list, doubly linked list, hash table.
* Пошук шляху у графі, алгоритм Дейкстри та A\*
* Мати поняття, що таке евристика (посилання є нижче, в варіанті №1)
* Розуміти, як працює і яке завдання у хеш-функцій *(зауважте, що існують також криптографічні хеш-функції, які не мають відношення до цієї роботи; якщо ви читаєте статтю про хеші і часто зустрічаєте слова "md5", "sha", "bcrypt", "криптографія" – ви читаєте не те, що треба)*

## [](#header-2)Варіант #0. Обчислення арифметичного виразу
Обчислити результат математичного виразу, що подається на вхід програми через *аргументи командного рядка* (будь ласка, уважно ще раз перечитайте останнє речення: не через файл і не через ввід у самій програмі). Наприклад, якщо ваша програма компілюється у файл calc.exe, вона має запускатися через командний рядок так:
```
> calc.exe 1 + 2 * 4+1 [Enter]
Result: 10
```
Зверніть увагу, що в деяких місцях є пробіли, в деяких вони відсутні.

*Перевіряти введені дані на правильність та будувати синтаксичне дерево (AST) в цьому варіанті не обов'язково!*

Для вирішення задачі треба реалізувати алгоритм [сортувальної станції](https://en.wikipedia.org/wiki/Shunting-yard_algorithm), що дозволяє обчислювати значення введеного арифметичного виразу. Стандартний спосіб зробити сортувальну станцію – використувати два стеки. Структуру стек необхідно написати власноруч.

*Складніше завдання (+1 бал):* Додати обробку від'ємних чисел, дужок та степенів *(також без перевірки на правильність вводу)*.

### Вхідні та вихідні дані
На вхід програми через аргументи командного рядка подається арифметичний вираз (`2 + 4*3`), що складається з чисел та символів +,-,\*,/. Вивід – результат обчислення (`14`).

### Посилання
* [Алгоритм сортувальної станції](https://en.wikipedia.org/wiki/Shunting-yard_algorithm)
* [Інфіксний, постфіксний та префіксний записи](http://www.cs.man.ac.uk/~pjj/cs2121/fix.html)
* Структура даних стек – операції, реалізація ([лінк](http://informatics.mccme.ru/mod/book/view.php?id=580), [ще лінк](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)))

Стек – одна із найбільш часто використовуваних структур. Використовується в [компіляторах](http://softwareengineering.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler) для розбору вихідних кодів. В [мікропроцесорах](http://stackoverflow.com/questions/1114047/what-is-the-role-of-stack-in-a-microprocessor) та [комп'ютерах](https://en.wikipedia.org/wiki/Call_stack) стек використовується для передачі параметрів в функції та рекурсивних викликів. Також використовується при обході дерев в глибину.

*\*Написання алгоритму shunting yard та власна імплементація стеку є обов'язковою умовою для здачі цього варіанту*

## [](#header-2)Варіант #1. Пошук найкоротшого шляху
Знайти в заданому лабіринті найкоротший шлях між двома точками за допомогою алгоритму Дейкстри.  Щоб написати цей алгоритм, треба скористатися структурою даних queue (черга), яку треба написати власноруч.

*Складніше завдання (+1 бал):* Реалізувати [алгоритм А\*](https://en.wikipedia.org/wiki/A*_search_algorithm) з простою пріоритетною чергою – без написання binary heap. 

### Вхідні та вихідні дані
Вхідний лабіринт задається у файлі форматованою двовимірною матрицею. В коді задається точка початку пошуку шляху та кінцева точка. Приклад вхідних даних:
```
X X X X X X X X   
X       X X   X   
X   X   X X   X   
X   X         X   
X   X   X   X X     
X   X   X   X X   
X   X       X X   
X X X X X X X X 
```
Вивід – візуалзіація роботи алгоритму (у файл або на екран)
```
X X X X X X X X   
X 5 6 7 X X e X   
X 4 X 8 X X d X   
X 3 X 9 a b c X   
X 2 X   X   X X    
X 1 X   X   X X  
X   X       X X  
X X X X X X X X  
```
### Посилання

* [Евристика](http://gamedev.stackexchange.com/questions/61850/in-a-star-how-does-the-heuristic-help-determine-your-path) в алгоритмах пошуку шляху в іграх
* [Нормальний](http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html) опис евристики в A\* від хлопців зі Стенфорду. Рекомендую почитати весь цикл
* [Алгоритм А\*](https://en.wikipedia.org/wiki/A*_search_algorithm)
* [Бінарна купа](https://en.wikipedia.org/wiki/Binary_heap) – використовується як швидка пріоритетна черга в A\*, проте ще раз наголошую, в цій лабораторній роботі її писати не треба
* [Пошук шляху](https://en.wikipedia.org/wiki/Pathfinding)

Пошук шляху дуже часто використовується для [трасування електричних плат](https://en.wikipedia.org/wiki/Routing_(electronic_design_automation)); для маршрутизації пакетів у [комп'ютерних мережах](https://en.wikipedia.org/wiki/Routing); для написання [AI в іграх](https://arongranberg.com/astar/). Черги та пріоритетні черги використовуються в ОС для контролю [доступу до ресурсів](https://github.com/torvalds/linux/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/prio_heap.h); для [імплементації](https://github.com/torvalds/linux/blob/master/include/linux/plist.h) м'ютексів та черги виконання процесів; в іграх та 3D-програмах для [рендерингу місцевості (terrain)](https://en.wikipedia.org/wiki/ROAM); в алгоритмах стискання зображень/музики/файлів – [кодування Хаффмана](https://en.wikibooks.org/wiki/JPEG_-_Idea_and_Practice/The_Huffman_coding).

*\*Написання алгоритму Дейкстри/A\* та черги є обов'язковою умовою для здачі цього варіанту*


## [](#header-2)Варіант #2. Словник
Розробити програму, яка на запит речення англійською мовою, видаватиме тлумачення кожного слова з цього речення або його переклад на іншу мову. Для цього найкраще буде використати структуру даних "хеш таблиця" (hash map, hash table, dictionary). Найпростіший спосіб зробити хеш таблицю – за допомогою масиву, в якому зберігаються зв'язні списки (linked list). Обидві структури треба написати власноруч. В простому варіанті завдання можна зазаделегідь виділити достатньо пам'яті для таблиці.

*Складніше завдання (+1 бал):* Ви не знаєте наперед, скільки елементів буде зберігатися в таблиці. Хеш-таблиця має розширюватися в два рази і перебудовуватися, коли кількість доданих значень перевищує 80% від кількості комірок в таблиці. Це стандартна поведінка, що використовується в більшості стандартних бібліотеках.

### Вхідні та вихідні дані
Ви можете використати готовий словник з [цього файла](./examples_3/dict_processed.txt) *(там 22 Мб тексту, в блокноті краще не відкривати)*. [Оригінал](http://www.gutenberg.org/ebooks/29765).

Слова даються програмі на вхід через стандартний потік вводу. Наприклад, якщо ви скомпілюєте свою програму в define.exe:
```
> define [Enter]
Type a sentence to get definition: hash [Enter]

HASH; Hash, n. Etym: [Formerly hachey, hachee, F. hachis, hacher to hash; of German origin; cf. G. hippe sickle, OHG. hippa, for happia.
Cf. Hatchet.]  1. That which is hashed or chopped up; meat and vegetables, especially such as have been already cooked, chopped into
small pieces and mixed.  2. A new mixture of old matter; a second preparation or exhibition. I can not bear elections, and still less
the hash of them over again in a first session. Walpole.
Type a word to get definition: ...
```

### Посилання
* [Відео лекції](https://www.youtube.com/watch?v=0M_kIqhwbFo) в MIT на тему хеш-таблиць 
* [Wiki](https://en.wikipedia.org/wiki/Hash_table)
* [Hash table](http://algs4.cs.princeton.edu/34hash/) з курсу прінстонського університету
* [Хороше пояснення](http://stackoverflow.com/a/730813) на stackoverflow

Таблиці використовуються практично в будь-якій складній програмі. В базах даних їх використовують для [швидкого пошуку полів](https://en.wikipedia.org/wiki/Database_index), хоча часто використовують складніші B-дерева; в інтерпретованих мовах програмування для збергіння структур (ключами є назви змінних, значеннями – їхні значення); в ядрі [Linux](https://github.com/torvalds/linux/blob/b3a3a9c441e2c8f6b6760de9331023a7906a4ac6/include/linux/hash.h) простіше сказати, де хеші не використовуються; хеш-таблиці є у більшості файлових систем, наприклад для реалізації [індексних дескрипторів](https://github.com/torvalds/linux/blob/42a2d923cc349583ebf6fdd52a7d35e1c2f7e6bd/fs/inode.c); для пошуку помилок у [файлових системах](https://github.com/torvalds/linux/blob/ff812d724254b95df76b7775d1359d856927a840/fs/btrfs/check-integrity.c); в алгоритмі [Рабіна—Карпа](https://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A0%D0%B0%D0%B1%D1%96%D0%BD%D0%B0_%E2%80%94_%D0%9A%D0%B0%D1%80%D0%BF%D0%B0) для пошуку рядків, який в свою чергу часто використовується для пошуку плагіату.

*\*Написання алгоритму хеш-функції та структур linked list і hash table є обов'язковою умовою для здачі цього варіанту*
